df_density_i$DNA_mass_pg = mta_dat4Plot$DNA_mass_pg[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
#plot the kernel density estimates by replicate with random colors
fig <- plot_ly(x = ~df_density_i$x,
y = ~df_density_i$y,
split = ~df_density_i$sample_rep,
fill = 'tozeroy',
hoverinfo = 'text',
text = ~paste(
'</br> Sample_replicate: ', df_density_i$sample_rep,
'</br> DNA mass (pg): ', df_density_i$DNA_mass_pg,
'</br> Event Count: ', df_density_i$count,
'</br> events/μL: ', df_density_i$events_perUL
)
)
#return a list holding the clean data table, and the plotted input data
cleanFlow_out = list(mta_dat4Plot, fig)
return(cleanFlow_out)
}
test_dat = read_excel("./test_batch_analysis.xlsx")
cleanFlow(test_dat)
test_dat
cleanFlow = function(mytable_in){
#read raw data
mytable = read_excel(mytable_in, col_names = F)
#produce a unified/coherent table of the data
#remove the rows with no data, in this case every third row
mytable = mytable[-(which(as.integer(rownames(mytable)) %% 3 == 0)),]
#copy the sample metadata into the same row as the analysis data
mytable[which(as.integer(rownames(mytable)) %% 2 == 0),1] = mytable[which(as.integer(rownames(mytable)) %% 2 == 0)-1,1]
#subset out just the analysis data, which now has the necessary metadata appended
clean_cytoDat = mytable[which(as.integer(rownames(mytable)) %% 2 == 0),]
#append the column names back and correct the first column name
colnames(clean_cytoDat) = mytable[1,]
colnames(clean_cytoDat)[1] = "metadata"
#clean up memory
rm(mytable)
#parse the metadata
#isolate the metadata
metaDat_parse = clean_cytoDat[,1]
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
#reconstruct the elements of the case ID
metaDat_parse$case_ID = paste(metaDat_parse$fiscal_year,metaDat_parse$case_ID, sep = "-")
metaDat_parse = metaDat_parse %>% select("case_ID","individual_ID","well_ID","plot_ID")
#loop through the individual_ID values and append replicate number to present replicates
metaDat_parse$replicate = NA
metaDat_parse$individual_ID = as.integer(metaDat_parse$individual_ID)
for (i in 1:nrow(metaDat_parse)) {
metaDat_parse$replicate[i] = length(which(as.vector(metaDat_parse$individual_ID[1:i]) %in% metaDat_parse$individual_ID[i]))
}
#re-order the columns to more logical orientation
metaDat_parse = metaDat_parse %>% select("case_ID","individual_ID","replicate","well_ID","plot_ID")
#append the formatted metadata to the analysis data
clean_cytoDat = cbind.data.frame(metaDat_parse,clean_cytoDat)
#drop the un-formatted metadata column, as this has now been parsed
clean_cytoDat = clean_cytoDat %>% select(-"metadata")
#sort by individual ID, as this is more logical than well
clean_cytoDat = clean_cytoDat %>% arrange(individual_ID,Count)
#format the control data individual ID
clean_cytoDat$individual_ID[which(clean_cytoDat$case_ID == "TIA-NA")] = "TIA"
#format CV and mean FL2-H to doubles for calculations
clean_cytoDat$`Mean FL2-H` = as.double(clean_cytoDat$`Mean FL2-H`)
clean_cytoDat$`CV FL2-H` = as.double(clean_cytoDat$`CV FL2-H`)
#construct a normal distribution for each sample based on mean and CV of FL2-H
#first calculate standard deviation based on the mean and CV
clean_cytoDat$standardDev = (clean_cytoDat$`CV FL2-H`/100)*clean_cytoDat$`Mean FL2-H`
#build a random normal distribution based on the mean and calculated standard deviation for each well, stored as list
for (i in 1:nrow(clean_cytoDat)) {
clean_cytoDat$distNorm[i] = I(list(rnorm(n = 10000,mean = clean_cytoDat$`Mean FL2-H`[i],sd = clean_cytoDat$standardDev[i])))
}
#insert any useful metadata that we want to show with the plot
clean_cytoDat$sample_rep = paste(clean_cytoDat$individual_ID,"_rep",clean_cytoDat$replicate, sep = "")
#TODO: we want to get the estimated DNA mass in here, this will be dependent upon a calculation based on the TIA control we select as our standard
clean_cytoDat$DNA_mass_pg = round((2.4/clean_cytoDat[which(clean_cytoDat$sample_rep == "TIA_rep1"),10])*clean_cytoDat[,10],3)
#convert the random normal distribution to a kernel density estimate for each rep for plotting
density1 <- density(clean_cytoDat$distNorm[[1]])
df_density_i = data.frame(x=density1$x, y=density1$y)
#append the replicate metadata for splitting in the plot
df_density_i$sample_rep = paste(clean_cytoDat$individual_ID[1],clean_cytoDat$replicate[1],sep = "_rep")
for (i in 2:nrow(clean_cytoDat)) {
density_i = density(clean_cytoDat$distNorm[[i]])
density_i = data.frame(x=density_i$x, y=density_i$y)
density_i$sample_rep = paste(clean_cytoDat$individual_ID[i],clean_cytoDat$replicate[i],sep = "_rep")
df_density_i = rbind.data.frame(df_density_i,density_i)
}
#TODO: R doesn't like the "Events / μL" name. We'll need to generalize this, but for now I've hardcoded it, as the input dataframe is still in development
mta_dat4Plot = clean_cytoDat[,c(2,3,6,7,15,16)]
#append the count and event per UL data based on sample_rep ID
df_density_i$count = mta_dat4Plot$Count[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
df_density_i$events_perUL = mta_dat4Plot$`Events / μL`[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
df_density_i$DNA_mass_pg = mta_dat4Plot$DNA_mass_pg[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
#plot the kernel density estimates by replicate with random colors
fig <- plot_ly(x = ~df_density_i$x,
y = ~df_density_i$y,
split = ~df_density_i$sample_rep,
fill = 'tozeroy',
hoverinfo = 'text',
text = ~paste(
'</br> Sample_replicate: ', df_density_i$sample_rep,
'</br> DNA mass (pg): ', df_density_i$DNA_mass_pg,
'</br> Event Count: ', df_density_i$count,
'</br> events/μL: ', df_density_i$events_perUL
)
)
#return a list holding the clean data table, and the plotted input data
cleanFlow_out = list(mta_dat4Plot, fig)
return(cleanFlow_out)
}
cleanFlow("./test_batch_analysis.xlsx")
cleanFlow("./test_batch_analysis.xlsx")[[1]]
test_dat = read_excel("./test_batch_analysis.xlsx", col_names = F)
cleanFlow = function(mytable_in){
#read raw data
# mytable = read_excel(mytable_in, col_names = F)
#produce a unified/coherent table of the data
#remove the rows with no data, in this case every third row
mytable = mytable_in[-(which(as.integer(rownames(mytable_in)) %% 3 == 0)),]
#copy the sample metadata into the same row as the analysis data
mytable[which(as.integer(rownames(mytable)) %% 2 == 0),1] = mytable[which(as.integer(rownames(mytable)) %% 2 == 0)-1,1]
#subset out just the analysis data, which now has the necessary metadata appended
clean_cytoDat = mytable[which(as.integer(rownames(mytable)) %% 2 == 0),]
#append the column names back and correct the first column name
colnames(clean_cytoDat) = mytable[1,]
colnames(clean_cytoDat)[1] = "metadata"
#clean up memory
rm(mytable)
#parse the metadata
#isolate the metadata
metaDat_parse = clean_cytoDat[,1]
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
#reconstruct the elements of the case ID
metaDat_parse$case_ID = paste(metaDat_parse$fiscal_year,metaDat_parse$case_ID, sep = "-")
metaDat_parse = metaDat_parse %>% select("case_ID","individual_ID","well_ID","plot_ID")
#loop through the individual_ID values and append replicate number to present replicates
metaDat_parse$replicate = NA
metaDat_parse$individual_ID = as.integer(metaDat_parse$individual_ID)
for (i in 1:nrow(metaDat_parse)) {
metaDat_parse$replicate[i] = length(which(as.vector(metaDat_parse$individual_ID[1:i]) %in% metaDat_parse$individual_ID[i]))
}
#re-order the columns to more logical orientation
metaDat_parse = metaDat_parse %>% select("case_ID","individual_ID","replicate","well_ID","plot_ID")
#append the formatted metadata to the analysis data
clean_cytoDat = cbind.data.frame(metaDat_parse,clean_cytoDat)
#drop the un-formatted metadata column, as this has now been parsed
clean_cytoDat = clean_cytoDat %>% select(-"metadata")
#sort by individual ID, as this is more logical than well
clean_cytoDat = clean_cytoDat %>% arrange(individual_ID,Count)
#format the control data individual ID
clean_cytoDat$individual_ID[which(clean_cytoDat$case_ID == "TIA-NA")] = "TIA"
#format CV and mean FL2-H to doubles for calculations
clean_cytoDat$`Mean FL2-H` = as.double(clean_cytoDat$`Mean FL2-H`)
clean_cytoDat$`CV FL2-H` = as.double(clean_cytoDat$`CV FL2-H`)
#construct a normal distribution for each sample based on mean and CV of FL2-H
#first calculate standard deviation based on the mean and CV
clean_cytoDat$standardDev = (clean_cytoDat$`CV FL2-H`/100)*clean_cytoDat$`Mean FL2-H`
#build a random normal distribution based on the mean and calculated standard deviation for each well, stored as list
for (i in 1:nrow(clean_cytoDat)) {
clean_cytoDat$distNorm[i] = I(list(rnorm(n = 10000,mean = clean_cytoDat$`Mean FL2-H`[i],sd = clean_cytoDat$standardDev[i])))
}
#insert any useful metadata that we want to show with the plot
clean_cytoDat$sample_rep = paste(clean_cytoDat$individual_ID,"_rep",clean_cytoDat$replicate, sep = "")
#TODO: we want to get the estimated DNA mass in here, this will be dependent upon a calculation based on the TIA control we select as our standard
clean_cytoDat$DNA_mass_pg = round((2.4/clean_cytoDat[which(clean_cytoDat$sample_rep == "TIA_rep1"),10])*clean_cytoDat[,10],3)
#convert the random normal distribution to a kernel density estimate for each rep for plotting
density1 <- density(clean_cytoDat$distNorm[[1]])
df_density_i = data.frame(x=density1$x, y=density1$y)
#append the replicate metadata for splitting in the plot
df_density_i$sample_rep = paste(clean_cytoDat$individual_ID[1],clean_cytoDat$replicate[1],sep = "_rep")
for (i in 2:nrow(clean_cytoDat)) {
density_i = density(clean_cytoDat$distNorm[[i]])
density_i = data.frame(x=density_i$x, y=density_i$y)
density_i$sample_rep = paste(clean_cytoDat$individual_ID[i],clean_cytoDat$replicate[i],sep = "_rep")
df_density_i = rbind.data.frame(df_density_i,density_i)
}
#TODO: R doesn't like the "Events / μL" name. We'll need to generalize this, but for now I've hardcoded it, as the input dataframe is still in development
mta_dat4Plot = clean_cytoDat[,c(2,3,6,7,15,16)]
#append the count and event per UL data based on sample_rep ID
df_density_i$count = mta_dat4Plot$Count[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
df_density_i$events_perUL = mta_dat4Plot$`Events / μL`[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
df_density_i$DNA_mass_pg = mta_dat4Plot$DNA_mass_pg[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
#plot the kernel density estimates by replicate with random colors
fig <- plot_ly(x = ~df_density_i$x,
y = ~df_density_i$y,
split = ~df_density_i$sample_rep,
fill = 'tozeroy',
hoverinfo = 'text',
text = ~paste(
'</br> Sample_replicate: ', df_density_i$sample_rep,
'</br> DNA mass (pg): ', df_density_i$DNA_mass_pg,
'</br> Event Count: ', df_density_i$count,
'</br> events/μL: ', df_density_i$events_perUL
)
)
#return a list holding the clean data table, and the plotted input data
cleanFlow_out = list(mta_dat4Plot, fig)
return(cleanFlow_out)
}
cleanFlow(test_dat)[[1]]
cleanFlow(test_dat)[[2]]
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
cleanFlow(test_dat)[[1]]
cleanFlow(test_dat)[[1]][2]
cleanFlow(test_dat)[[1]]
mytable_in = test_dat
#read raw data
# mytable = read_excel(mytable_in, col_names = F)
#produce a unified/coherent table of the data
#remove the rows with no data, in this case every third row
mytable = mytable_in[-(which(as.integer(rownames(mytable_in)) %% 3 == 0)),]
#copy the sample metadata into the same row as the analysis data
mytable[which(as.integer(rownames(mytable)) %% 2 == 0),1] = mytable[which(as.integer(rownames(mytable)) %% 2 == 0)-1,1]
#subset out just the analysis data, which now has the necessary metadata appended
clean_cytoDat = mytable[which(as.integer(rownames(mytable)) %% 2 == 0),]
#append the column names back and correct the first column name
colnames(clean_cytoDat) = mytable[1,]
colnames(clean_cytoDat)[1] = "metadata"
#clean up memory
rm(mytable)
#parse the metadata
#isolate the metadata
metaDat_parse = clean_cytoDat[,1]
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
#parse the metadata
#isolate the metadata
metaDat_parse = clean_cytoDat[,1]
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
clean_cytoDat
#parse the metadata
#isolate the metadata
metaDat_parse = clean_cytoDat[,1]
metaDat_parse
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
cleanFlow(test_dat)[[1]]
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
data.table::as.data.table(cleanFlow(test_dat)[[1]])
library(DT)
datatable(cleanFlow(test_dat)[[1]])
runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("rhandsontable")
rhandsontable::rhandsontable(cleanFlow(test_dat)[[1]])
library(rhandsontable)
rhandsontable(cleanFlow(test_dat)[[1]])
df = cleanFlow(test_dat)[[1]]
rhandsontable(df)
rhandsontable(df)%>%
hot_col("factor_allow", allowInvalid = TRUE)
df
df = as.data.frame(cleanFlow(test_dat)[[1]])
df
rhandsontable(df)
rhandsontable(df, color = "black")
DF = data.frame(integer = 1:10,
numeric = rnorm(10),
logical = rep(TRUE, 10),
character = LETTERS[1:10],
factor = factor(letters[1:10], levels = letters[10:1],
ordered = TRUE),
factor_allow = factor(letters[1:10], levels = letters[10:1],
ordered = TRUE),
date = seq(from = Sys.Date(), by = "days", length.out = 10),
stringsAsFactors = FALSE)
rhandsontable(DF, width = 600, height = 300) %>%
hot_col("factor_allow", allowInvalid = TRUE)
color_renderer <- "
function(instance, td) {
Handsontable.renderers.TextRenderer.apply(this, arguments);
td.style.color = 'red';
}
"
rhandsontable(DF) %>%
hot_col("b", renderer = color_renderer)
DF
rhandsontable(DF) %>%
hot_col("integer", renderer = color_renderer)
rhandsontable(DF) %>%
hot_col(1:ncol(DF), renderer = color_renderer)
color_renderer <- "
function(instance, td) {
Handsontable.renderers.TextRenderer.apply(this, arguments);
td.style.color = 'black';
}
"
rhandsontable(DF) %>%
hot_col(1:ncol(DF), renderer = color_renderer)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library(DT)
library(dplyr)
library(readxl)
library(tidyr)
library(ggplot2)
library(plotly)
test_dat = read_excel("./test_batch_analysis.xlsx", col_names = F)
mytable_in = test_dat
cleanFlow = function(mytable_in,control_ID){
#read raw data
# mytable = read_excel(mytable_in, col_names = F)
#produce a unified/coherent table of the data
#remove the rows with no data, in this case every third row
mytable = mytable_in[-(which(as.integer(rownames(mytable_in)) %% 3 == 0)),]
#copy the sample metadata into the same row as the analysis data
mytable[which(as.integer(rownames(mytable)) %% 2 == 0),1] = mytable[which(as.integer(rownames(mytable)) %% 2 == 0)-1,1]
#subset out just the analysis data, which now has the necessary metadata appended
clean_cytoDat = mytable[which(as.integer(rownames(mytable)) %% 2 == 0),]
#append the column names back and correct the first column name
colnames(clean_cytoDat) = mytable[1,]
colnames(clean_cytoDat)[1] = "metadata"
#clean up memory
rm(mytable)
#parse the metadata
#isolate the metadata
metaDat_parse = clean_cytoDat[,1]
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
#reconstruct the elements of the case ID
metaDat_parse$case_ID = paste(metaDat_parse$fiscal_year,metaDat_parse$case_ID, sep = "-")
metaDat_parse = metaDat_parse %>% select("case_ID","individual_ID","well_ID","plot_ID")
#loop through the individual_ID values and append replicate number to present replicates
metaDat_parse$replicate = NA
metaDat_parse$individual_ID = as.integer(metaDat_parse$individual_ID)
for (i in 1:nrow(metaDat_parse)) {
metaDat_parse$replicate[i] = length(which(as.vector(metaDat_parse$individual_ID[1:i]) %in% metaDat_parse$individual_ID[i]))
}
#re-order the columns to more logical orientation
metaDat_parse = metaDat_parse %>% select("case_ID","individual_ID","replicate","well_ID","plot_ID")
#append the formatted metadata to the analysis data
clean_cytoDat = cbind.data.frame(metaDat_parse,clean_cytoDat)
#drop the un-formatted metadata column, as this has now been parsed
clean_cytoDat = clean_cytoDat %>% select(-"metadata")
#sort by individual ID, as this is more logical than well
clean_cytoDat = clean_cytoDat %>% arrange(individual_ID,Count)
#format the control data individual ID
clean_cytoDat$individual_ID[which(clean_cytoDat$case_ID == "TIA-NA")] = "TIA"
#format CV and mean FL2-H to doubles for calculations
clean_cytoDat$`Mean FL2-H` = as.double(clean_cytoDat$`Mean FL2-H`)
clean_cytoDat$`CV FL2-H` = as.double(clean_cytoDat$`CV FL2-H`)
#construct a normal distribution for each sample based on mean and CV of FL2-H
#first calculate standard deviation based on the mean and CV
clean_cytoDat$standardDev = (clean_cytoDat$`CV FL2-H`/100)*clean_cytoDat$`Mean FL2-H`
#build a random normal distribution based on the mean and calculated standard deviation for each well, stored as list
for (i in 1:nrow(clean_cytoDat)) {
clean_cytoDat$distNorm[i] = I(list(rnorm(n = 10000,mean = clean_cytoDat$`Mean FL2-H`[i],sd = clean_cytoDat$standardDev[i])))
}
#insert any useful metadata that we want to show with the plot
clean_cytoDat$sample_rep = paste(clean_cytoDat$individual_ID,"_rep",clean_cytoDat$replicate, sep = "")
#TODO: we want to get the estimated DNA mass in here, this will be dependent upon a calculation based on the TIA control we select as our standard
clean_cytoDat$DNA_mass_pg = round((2.4/clean_cytoDat[which(clean_cytoDat$sample_rep == control_ID),10])*clean_cytoDat[,10],3)
#convert the random normal distribution to a kernel density estimate for each rep for plotting
density1 <- density(clean_cytoDat$distNorm[[1]])
df_density_i = data.frame(x=density1$x, y=density1$y)
#append the replicate metadata for splitting in the plot
df_density_i$sample_rep = paste(clean_cytoDat$individual_ID[1],clean_cytoDat$replicate[1],sep = "_rep")
for (i in 2:nrow(clean_cytoDat)) {
density_i = density(clean_cytoDat$distNorm[[i]])
density_i = data.frame(x=density_i$x, y=density_i$y)
density_i$sample_rep = paste(clean_cytoDat$individual_ID[i],clean_cytoDat$replicate[i],sep = "_rep")
df_density_i = rbind.data.frame(df_density_i,density_i)
}
#TODO: R doesn't like the "Events / μL" name. We'll need to generalize this, but for now I've hardcoded it, as the input dataframe is still in development
mta_dat4Plot = clean_cytoDat[,c(2,3,6,7,15,16)]
#append the count and event per UL data based on sample_rep ID
df_density_i$count = mta_dat4Plot$Count[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
df_density_i$events_perUL = mta_dat4Plot$`Events / μL`[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
df_density_i$DNA_mass_pg = mta_dat4Plot$DNA_mass_pg[match(df_density_i$sample_rep, mta_dat4Plot$sample_rep)]
#plot the kernel density estimates by replicate with random colors
fig <- plot_ly(x = ~df_density_i$x,
y = ~df_density_i$y,
split = ~df_density_i$sample_rep,
fill = 'tozeroy',
hoverinfo = 'text',
text = ~paste(
'</br> Sample_replicate: ', df_density_i$sample_rep,
'</br> DNA mass (pg): ', df_density_i$DNA_mass_pg,
'</br> Event Count: ', df_density_i$count,
'</br> events/μL: ', df_density_i$events_perUL
)
)
#return a list holding the clean data table, and the plotted input data
cleanFlow_out = list(mta_dat4Plot, fig)
return(cleanFlow_out)
}
test_dat = read_excel("./test_batch_analysis.xlsx",col_names = F)
cleanFlow(test_dat,"TIA_rep1")[[1]]
cleanFlow(test_dat,"TIA_rep1")[[2]]
library(rhandsontable)
df = as.data.frame(cleanFlow(test_dat)[[1]])
library(rhandsontable)
df = as.data.frame(cleanFlow(test_dat,"TIA_rep1")[[1]])
rhandsontable(df)
DF = data.frame(integer = 1:10,
numeric = rnorm(10),
logical = rep(TRUE, 10),
character = LETTERS[1:10],
factor = factor(letters[1:10], levels = letters[10:1],
ordered = TRUE),
factor_allow = factor(letters[1:10], levels = letters[10:1],
ordered = TRUE),
date = seq(from = Sys.Date(), by = "days", length.out = 10),
stringsAsFactors = FALSE)
rhandsontable(DF, width = 600, height = 300) %>%
hot_col("factor_allow", allowInvalid = TRUE)
# Custom renderer function
color_renderer <- "
function(instance, td) {
Handsontable.renderers.TextRenderer.apply(this, arguments);
td.style.color = 'black';
}
"
rhandsontable(DF) %>%
hot_col(1:ncol(DF), renderer = color_renderer)
color_renderer <- "
function(instance, td) {
Handsontable.renderers.TextRenderer.apply(this, arguments);
td.style.color = 'black';
}
"
rhandsontable(DF) %>%
hot_col(1:ncol(DF), renderer = color_renderer)
DF
rhandsontable(df) %>%
hot_col(1:ncol(df), renderer = color_renderer)
test_dat = read_excel("./test_batch_analysis.xlsx", col_names = F)
control_ID = "TIA_rep1"
#read raw data
# mytable = read_excel(mytable_in, col_names = F)
#produce a unified/coherent table of the data
#remove the rows with no data, in this case every third row
mytable = mytable_in[-(which(as.integer(rownames(mytable_in)) %% 3 == 0)),]
#read raw data
# mytable = read_excel(mytable_in, col_names = F)
#produce a unified/coherent table of the data
#remove the rows with no data, in this case every third row
mytable = mytable_in[-(which(as.integer(rownames(mytable_in)) %% 3 == 0)),]
mytable
#copy the sample metadata into the same row as the analysis data
mytable[which(as.integer(rownames(mytable)) %% 2 == 0),1] = mytable[which(as.integer(rownames(mytable)) %% 2 == 0)-1,1]
mytable
#copy JUST the sample metadata into the same row as the analysis data
mytable[which(as.integer(rownames(mytable)) %% 2 == 0),1] = mytable[which(as.integer(rownames(mytable)) %% 2 == 0)-1,1]
mytable
#subset out just the analysis data, which now has the necessary metadata appended
clean_cytoDat = mytable[which(as.integer(rownames(mytable)) %% 2 == 0),]
clean_cytoDat
mytable
clean_cytoDat
mytable
#append the column names back and correct the first column name
colnames(clean_cytoDat) = mytable[1,]
colnames(clean_cytoDat)[1] = "metadata"
#clean up memory
rm(mytable)
clean_cytoDat
#parse the metadata
#isolate the metadata
metaDat_parse = clean_cytoDat[,1]
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
metaDat_parse
metaDat_parse = clean_cytoDat[,1]
#split apart all the elements
metaDat_parse = metaDat_parse %>% separate(metadata, c("NA","plot_ID","well_ID","fiscal_year","case_ID","individual_ID"))
metaDat_parse
metaDat_parse$case_ID = paste(metaDat_parse$fiscal_year,metaDat_parse$case_ID, sep = "-")
metaDat_parse = metaDat_parse %>% select("case_ID","individual_ID","well_ID","plot_ID")
metaDat_parse
#loop through the individual_ID values and append replicate number to present replicates
metaDat_parse$replicate = NA
metaDat_parse$individual_ID = as.integer(metaDat_parse$individual_ID)
metaDat_parse
metaDat_parse$individual_ID = as.integer(metaDat_parse$individual_ID)
for (i in 1:nrow(metaDat_parse)) {
metaDat_parse$replicate[i] = length(which(as.vector(metaDat_parse$individual_ID[1:i]) %in% metaDat_parse$individual_ID[i]))
}
#re-order the columns to more logical orientation
metaDat_parse = metaDat_parse %>% select("case_ID","individual_ID","replicate","well_ID","plot_ID")
metaDat_parse
mytable_in
clean_cytoDat
